---
layout: article  
title: 理解事务隔离级别  
date: 2021-09-21  
category: MySQL  
tags: [MySQL, 事务]
---

事务的隔离性实际上比想象的要复杂，在 SQL 标准中定义了四种隔离级别
1. Read Uncommitted/未提交读  
    在此级别中，即使事务中的修改未提交，也会被其他事务“看见”，这被称为“脏读”，这会导致很多问题。
2. Read Commited/读已提交
    在此级别中，解决了脏读的问题，满足了隔离性的简单定义：事务内的修改只有在提交才能被其他事务后“看见”，换句话说，一个事务从开始到提交，其中所作的所有修改对其他事务都是不可见的。
    但是这个隔离级别也有缺陷：事务A读取一条数据，事务B修改了这条数据并提交，当事务A再次读取该数据，得到的结果和上一次不同，所以这个隔离级别也叫：不可重复读（nonrepeatable read）
3. Repeatable Read/可重复读
    在此级别中，解决了不可重复读的问题，保证了一个事务中对同一数据的多次读取结果是一致的
    但是这个隔离级别也有缺陷：事务A读取一批数据，事务B在这批数据中插入了一条或多条数据，当事务A再次读取这批数据，得到的结果和上一次不同更多行数据
    这也叫幻读（Phantom Read）
    可重复读是 MySQL 的默认事务隔离级别，InnoDB 通过多版本并发控制（[[MVCC]], Multiversion Concurrency Control)解决了幻读的问题
4. Serializable/可串行化
    Serializable是最高的隔离级别，它通过强制事务串行化执行，保证了数据的一致性，解决了幻读的问题。
    但是该隔离界别在并发下会导致大量的超时和锁争用，表现不佳。
    实际应用中很少使用用到这个隔离级别，只有在非常需要确保数据一致性并且可以接受没有并发的情况下才考虑使用。

## 参考
<https://segmentfault.com/a/1190000039809030>