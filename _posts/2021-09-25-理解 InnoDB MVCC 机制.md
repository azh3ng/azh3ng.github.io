---
layout: article  
title: 理解 InnoDB MVCC 机制  
date: 2021-09-25  
category:  
tags: []  
---

# 理解 InnoDB MVCC 机制

MVCC，全称 Multi-Version Concurrency Control，即多版本并发控制。
要理解数据库的 MVCC 需要先了解数据库的[事务隔离级别](./事务隔离界别.md)，其中 Read Uncommitted 几乎没有隔离性，所以无需做任何处理；Serializable 要保证每个事务强隔离，所以对每个事务强行串行化，所以无需考虑并发导致的数据不一致。
但是 Read Commited 和 Repeatable Read 需要保证每次读取到的数据的一致性。Read Commited 不能读到其他事务未提交的修改，Repeatable Read 在此基础上还需要保证当前事务中每次读取到的数据都是一致的。

以 Repeatable Read 为例，思考如何实现在并发情况下，当前事务的修改不被其他事务读取，自己读取不到其他未提交事务的修改，同时当前事务中每次读取都是一致的。
假设场景，只有一个表，且表中只有一行数据，对于这一行数据：
- `事务1`：修改，且已提交 1
- `事务2`：修改，还未提交
- `事务3`：修改，且已提交 2
- `事务4`：修改，还未提交
- **`事务A`**：**查询**，且未结束
- `事务5`：修改，且已提交 3
- `事务6`：修改，还未提交

以上事务是顺序开启。

对于**`事务A`**的查询，得到的结果应该是事务 3 的修改：
- `事务1`的修改被`事务5`和`事务3`的修改提交覆盖，所以查询不到
- `事务2`的修改还未提交，所以无法被`事务A`查询到
- `事务4`同`事务2`
- `事务5`的修改虽然已经提交，但是在`事务A`查询开启时，`事务5`还未开启，所以`事务5`的所有修改对于`事务A`不可见
- `事务6`同`事务5`，无论事务6是否提交，在`事务A`查询开启时，`事务6`还未开启，所以`事务6`的所有修改对于`事务A`不可见

想要达到这样的效果，首先想到的就是在开启事务的瞬间，把所有数据进行完整备份，在备份上进行查询和修改，但是当数据库的数据量变得很大这种方式的性能极低以至于不可用。
其次想到的是对于事务修改的行进行加锁，其他事务无法同时查询或修改，对于事务查询的行进行加锁，其他事务无法同时修改。但是这对于高并发的场景同样性能很差。

MVCC 可以解决 Read Commited 和 Repeatable Read 面临的问题。
它的做法是对每一行数据维护一个**修改链**，每次修改都将原始行数据进行备份、修改，并添加到修改链的头部，
同时在行中添加两个隐藏的列(trx_id 和 roll_pointer)，其中一列(trx_id)记录此次修改的**事务ID**，另一列(roll_pointer)指向修改前的数据（这么说只是为了方便，实际指向的是 undo log 中的记录）。
数据库对事务ID进行强制的升序分配，这样事务在查询数据时就可以根据事务ID的大小来判断应该读取修改链中的哪一行数据。

## ReadView 机制
ReadView 机制就是用来判断当前事务能够看见哪些版本的。
在开启事务的时刻不会创建 ReadView，只有在进行查询（包括增删改操作）时，才会创建 ReadView。
一个 ReadView 主要包含如下几个部分：
- `m_ids`：未提交的事务ID数组；生成 ReadView 时有哪些事务在执行但是还没提交的（称为 ”活跃事务“），这些活跃的事务 ID 就存在这个字段里
- `min_trx_id`：m_ids 里最小的值
- `max_trx_id`：生成 ReadView 时 InnoDB 将分配给下一个事务的 ID 的值（事务 ID 是递增分配的，越后面申请的事务 ID 越大）
- `creator_trx_id`：当前创建 ReadView 事务的 ID

在确定哪个版本可见时，采用以下逻辑
1. 判断该数据的`trx_id`是否等于 `creator_trx_id`，如果等于，表示这条数据是自己插入或修改的，可以读到
2. 判断该数据的`trx_id`是否小于 `min_trx_id`，如果小于，表示这个版本的数据是在当前所有活跃事务之前修改的，并且已经提交，可以读到
3. 如果被访问版本的`trx_id`大于或等于ReadView中的`max_trx_id`值，说明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被读出来。
4. 如果生成被访问版本的`trx_id`在`min_trx_id`和`max_trx_id`之间，那就需要判断下`trx_id`在不在`m_ids`中：如果在，说明创建ReadView的时候，生成该版本的事务还是活跃的（没有被提交），该版本不可以被读出来；如果不在，说明创建ReadView的时候，生成该版本的事务已经被提交了，该版本可以被读出来。
如果该数据的版本不可以被读出来，那么就顺着roll_pointer 找到上一个版本的数据，继续做上述判断。如果找到版本链最末尾的的数据判断还是不可见，则表示该数据对当前事务完全不可见，查询结果就不应该包含这条记录了。

以上面的例子进行分析，在事务A 查询的时刻，创建了一个 ReadView，对应的
- `m_ids`: [事务2，事务4]
- `min_trx_id`: 事务2
- `max_trx_id`：事务5
- `creator_trx_id`：事务A（查询实际上分配的是假的事务ID，这个后面讲）

这是有两个情景:
情景一: 在事务 A 查询第一次时，事务5还未开启，此时查询到的结果是事务4 的修改，但是事务4在`m_ids`中，表示修改未提交，于是根据版本链找到事务3的修改，事务3版本的数据不等于当前事务ID，不小于`min_trx_id`，不大于等于`max_trx_id`，也不在`m_ids`中，表示事务3的修改可见，即返回事务3版本的数据。
情景二：在事务A查询一次后，事务5和事务6相继开启或提交，此时事务A再次查询：查询到的结果是事务6的修改，由于事务6的`trx_id`大于`max_trx_id`，修改不可见，根据 roll_pointer 找到事务5 的修改，事务5的修改与事务6相同，`trx_id`大于`max_trx_id`，继而找到事务4的修改版本，剩下的判断过程同情景一。


## 参考
<https://www.cnblogs.com/cswiki/p/15338928.html>
<https://blog.csdn.net/Win_Dan/article/details/119171531>
<https://www.cnblogs.com/CodeBear/p/12710670.html>
<https://segmentfault.com/a/1190000039809030>

